PROGRAM LOSACC
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Compute the line-of-sight gravity difference between two GRACE-FO satellites
!   using spherical harmonic models of geopotential field (L2, AOD1B, otides, etc.)
!
! (c) Shin-Chan Han, 16SEP21
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IMPLICIT NONE
REAL*8,PARAMETER   :: PI=3.14159265358979D0
REAL*8,PARAMETER   :: D2R=PI/180D0
INTEGER            :: LMAX,L1,L2,L,M,LENG,I,ID1,ID2,ID3,ID4,NCNT,NPOINT
REAL*8             :: CLM,SLM,GM,R0,ACC1(3),ACC2(3),R2(3,3),R3(3,3),accel
REAL*8,ALLOCATABLE :: CILM(:,:,:),COE(:),AVEC1(:,:),AVEC2(:,:), &
                      et(:),e12(:,:), &
                      SC_LAT1(:),SC_LON1(:),SC_RADIUS1(:), &
                      SC_LAT2(:),SC_LON2(:),SC_RADIUS2(:)
CHARACTER(LEN=120) :: IFILE1,IFILE2,OFILE

CALL GETARG(1,IFILE1) !<<<COEF
CALL GETARG(2,IFILE2) !<<<ORBIT
CALL GETARG(3,OFILE)  !>>>LGD
OPEN(1,FILE=IFILE1,STATUS='OLD')
OPEN(2,FILE=IFILE2,STATUS='OLD')
OPEN(3,FILE=OFILE)

READ(*,*) GM,R0,LMAX,L1
!GM=4902.801076d9; R0=1738d3  !GRAIL models for the Moon

!
! READ COEFFICIENT FILE
!
LENG=(LMAX+1)**2
ALLOCATE(CILM(LMAX+1,LMAX+1,2),COE(LENG))
L=0
CILM=0D0
DO WHILE(L<=LMAX)
   READ(1,*,END=10,ERR=10) L,M,CLM,SLM
   if( l >= L1 .and. l <= LMAX ) then   
     CILM(L+1,M+1,1)=CLM
     CILM(L+1,M+1,2)=SLM
   endif
ENDDO
10 CONTINUE
CLOSE(1)
ID1=1
ID3=(LMAX+1)*(LMAX+2)/2+1
COE=0D0
DO M=0,LMAX
  ID2=ID1+LMAX-M
  COE(ID1:ID2)=CILM(M+1:LMAX+1,M+1,1)
  ID1=ID2+1
  IF(M>0) THEN
    ID4=ID3+LMAX-M
    COE(ID3:ID4)=CILM(M+1:LMAX+1,M+1,2)
    ID3=ID4+1
  ENDIF
ENDDO
!
! READ ORBIT FILE
!
NCNT=0
DO WHILE(.TRUE.)
  READ(2,*,END=20)
  NCNT=NCNT+1
ENDDO
20 REWIND(2)
NPOINT=NCNT
ALLOCATE( et(NPOINT), SC_LAT1(NPOINT), SC_LON1(NPOINT), SC_RADIUS1(NPOINT), &
          SC_LAT2(NPOINT), SC_LON2(NPOINT), SC_RADIUS2(NPOINT), e12(3,NPOINT) )
DO I=1,NPOINT
  read(2,*) et(i),sc_lat1(i),sc_lon1(i),sc_radius1(i),sc_lat2(i),sc_lon2(i),sc_radius2(i),e12(1:3,i)
ENDDO
CLOSE(2)
!
! COMPUTE THE ACCELERATION VECTOR
!
ALLOCATE(AVEC1(3,LENG),AVEC2(3,LENG))
DO I=1,NPOINT
  CALL GET_ACC_VEC_SH(LMAX,R0,SC_RADIUS1(I),SC_LAT1(I),SC_LON1(I),1,AVEC1)
  ACC1 = MATMUL(AVEC1,COE) ! ACCELERATION VECTOR (ECF/NED)
  CALL FILLMAT(2,COS(PI-(90D0-SC_LAT1(I))*D2R),SIN(PI-(90D0-SC_LAT1(I))*D2R),R2)
  CALL FILLMAT(3,COS(-SC_LON1(I)*D2R),SIN(-SC_LON1(I)*D2R),R3)
  ACC1 = MATMUL(MATMUL(R3,R2),ACC1) ! ACCELERATION VECTOR (ECF/XYZ)
  ACC1 = ACC1 * GM/R0 ![m/s^2]

  CALL GET_ACC_VEC_SH(LMAX,R0,SC_RADIUS2(I),SC_LAT2(I),SC_LON2(I),1,AVEC2)
  ACC2 = MATMUL(AVEC2,COE)
  CALL FILLMAT(2,COS(PI-(90D0-SC_LAT2(I))*D2R),SIN(PI-(90D0-SC_LAT2(I))*D2R),R2)
  CALL FILLMAT(3,COS(-SC_LON2(I)*D2R),SIN(-SC_LON2(I)*D2R),R3)
  ACC2 = MATMUL(MATMUL(R3,R2),ACC2)
  ACC2 = ACC2 * GM/R0 ![m/s^2]

  accel = dot_product(acc1-acc2,e12(:,i))
! ACCELERATION LOS-COMPONENT
  WRITE(3,'(4E23.15)') accel, acc1-acc2
ENDDO
CLOSE(3)
END PROGRAM LOSACC



SUBROUTINE GET_ACC_VEC_SH(NMAX,R0,R,LAT,LON,ISELECT,AVEC)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ACCELERATION VECTOR; SPHERICAL HARMONIC BASIS
!   GM/R0 * AVEC * [CLM/SLM] GIVES ACCELERATION VECTOR IN LOCAL TRIAD (NED)
!   ISELECT == 1 => NORTH/EAST/RADIAL-DOWN COMPONENTS [UNIT: INVERSE OF UNIT OF R]
!   OTHERWISE    => DERIVATIVES IN RADIAL-UP/COLATITUDE/LONGITUDE
!
! 04APR07 ... CODED BY Shin-Chan Han, NASA/GSFC
! 16AUG07 ... REORDER CLM/SLM SEQUENCE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IMPLICIT NONE
REAL*8,PARAMETER:: PI  = 3.14159265358979D0
REAL*8,PARAMETER:: D2R = PI/180D0
INTEGER:: NMAX,L,M,N,K,ID1,ID2,ISELECT
REAL*8 :: R0,R,LAT,LON,AVEC(3,(NMAX+1)**2)
REAL*8 :: COS_CLAT,SIN_CLAT,COS_MLON,SIN_MLON,R0_R,R0_R_M,FACTOR,R_FACTOR
REAL*8 :: PBAR(NMAX+1),PBAR1(NMAX+1),PBAR2(NMAX+1)
REAL*8 :: RM2(3,3),RM3(3,3),VEC1(3),VEC2(3)
COS_CLAT = COS((90D0-LAT)*D2R)
SIN_CLAT = SIN((90D0-LAT)*D2R)
R0_R     = R0/R
R0_R_M   = 1D0
M=0
	R_FACTOR = 1D0
	L = NMAX+1
	CALL LGDR2(COS_CLAT,NMAX,M,PBAR(1:L),PBAR1(1:L),PBAR2(1:L))
	DO K=1,L
		R_FACTOR = R_FACTOR * R0_R  !(R0/R)**(M+K)
		IF (ISELECT==1) THEN  !NORTH/EAST/RADIAL-DOWN
			AVEC(1,K) = R_FACTOR * PBAR1(K) * (-1D0/R)
			AVEC(2,K) = 0D0
			AVEC(3,K) = R_FACTOR * PBAR(K) * K/R
		ELSE  !RADIAL-UP/COLATITUDE/LONGITUDE
			AVEC(1,K) = -K/R * R_FACTOR * PBAR(K)
			AVEC(2,K) = R_FACTOR * PBAR1(K)
			AVEC(3,K) = 0D0
		ENDIF
	ENDDO
ID1 = NMAX+1
ID2 = (NMAX+1)*(NMAX+2)/2
DO M=1,NMAX
	COS_MLON = COS(M*LON*D2R)
	SIN_MLON = SIN(M*LON*D2R)
	R0_R_M   = R0_R_M * R0_R
	R_FACTOR = R0_R_M
	L = NMAX-M+1
	CALL LGDR2(COS_CLAT,NMAX,M,PBAR(1:L),PBAR1(1:L),PBAR2(1:L))
	DO K=1,L
		ID1 = ID1 + 1
		ID2 = ID2 + 1
		R_FACTOR = R_FACTOR * R0_R  !(R0/R)**(M+K)
		IF (ISELECT==1) THEN  !NORTH/EAST/RADIAL-DOWN
			FACTOR      = R_FACTOR * PBAR1(K) * (-1D0/R)
			AVEC(1,ID1) = FACTOR * COS_MLON
			AVEC(1,ID2) = FACTOR * SIN_MLON
			FACTOR      = R_FACTOR * PBAR(K) * (1D0/R/SIN_CLAT)
			AVEC(2,ID1) = FACTOR * (-M) * SIN_MLON
			AVEC(2,ID2) = FACTOR * ( M) * COS_MLON
			FACTOR      = R_FACTOR * PBAR(K) * (M+K)/R
			AVEC(3,ID1) = FACTOR * COS_MLON
			AVEC(3,ID2) = FACTOR * SIN_MLON
		ELSE  !RADIAL-UP/COLATITUDE/LONGITUDE
			FACTOR      = -(M+K)/R * R_FACTOR * PBAR(K)
			AVEC(1,ID1) = FACTOR * COS_MLON
			AVEC(1,ID2) = FACTOR * SIN_MLON
			FACTOR      = R_FACTOR * PBAR1(K)
			AVEC(2,ID1) = FACTOR * COS_MLON
			AVEC(2,ID2) = FACTOR * SIN_MLON
			FACTOR      = R_FACTOR * PBAR(K)
			AVEC(3,ID1) = FACTOR * (-M) * SIN_MLON
			AVEC(3,ID2) = FACTOR * ( M) * COS_MLON
		ENDIF
	ENDDO
ENDDO
RETURN
END SUBROUTINE GET_ACC_VEC_SH



SUBROUTINE FILLMAT(AX,C,S,MAT)
IMPLICIT NONE
!     FILL ROTATION MATRIX
!     AX = AXIS OF ROTATION, C = COS(ANGLE), S = SIN(ANGLE)     
INTEGER :: AX
REAL*8  :: C,S,MAT(3,3)
IF (AX.EQ.1) THEN 
	MAT(1,1) = 1D0
	MAT(1,2) = 0D0
	MAT(1,3) = 0D0
	MAT(2,1) = 0D0
	MAT(3,1) = 0D0
	MAT(2,2) = C
	MAT(3,3) = C
	MAT(2,3) = S    
	MAT(3,2) = -S
END IF
IF (AX.EQ.2) THEN 
	MAT(2,2) = 1D0
	MAT(1,2) = 0D0
	MAT(2,1) = 0D0
	MAT(2,3) = 0D0
	MAT(3,2) = 0D0
	MAT(1,1) = C
	MAT(3,3) = C
	MAT(1,3) = -S    
	MAT(3,1) = S
END IF
IF (AX.EQ.3) THEN 
	MAT(1,3) = 0D0
	MAT(2,3) = 0D0
	MAT(3,1) = 0D0
	MAT(3,2) = 0D0
	MAT(3,3) = 1D0
	MAT(1,1) = C
	MAT(2,2) = C
	MAT(1,2) = S    
	MAT(2,1) = -S
END IF
END SUBROUTINE FILLMAT



SUBROUTINE LGDR2(T,NMAX,M,PBAR,PBAR1,PBAR2)
! THIS CALCULATES THE FULLY NORMALIZED LEGENDRE FUNCTION WITH GIVEN ORDER(M),
! MAXIMUM DEGREE (NMAX), AND GIVEN EVALUATION POINT, T (COSINES OF COLATITUDE).
! THIS RETURNS ALL PN,M, P'N,M, AND P''N,M (M=<N<=NMAX).
! THE RECURSION FORMULAR FOR THE FUNCTION ITSELF IS GIVEN IN JEKELI(1996).
! THE RECURSION FORMULAR FOR THE 1ST DERIVATIVE IS GIVEN IN TSCHERNING, ET AL(1983).
! THE FORMULAR FOR THE 2ND DERIVATIVE IS FROM THE ASSOCIATE LEGENDRE EQUATION.
! NOTE : EQUATIONS GIVEN IN TSCHERNING, ET AL(1983) HAVE ERRATA.
!
! Shin-Chan HAN, 1/24/01 (MODIFIED FOR CRAY T94 2/13/01)
!
IMPLICIT NONE
INTEGER :: NMAX,M,I
REAL*8 :: PBAR(NMAX-M+1),PBAR1(NMAX-M+1),PBAR2(NMAX-M+1),T,P00,P11,C,D
!
! THE FULLY NORMALIZED ASSOCIATED LEGENDRE FUNCTION
! PM,M : JEKEIL (A.3C) & (A.3D) , P'M,M : TSCHERNING (7)
P00=1D0; P11=SQRT(3D0*(1D0-T**2))
IF(M>=1) THEN
	PBAR(1)=P11; PBAR1(1)=SQRT(3D0)*T
	DO I=2,M
		PBAR1(1)=SQRT((2D0*I+1D0)/(2D0*I))*(SQRT(1D0-T**2)*PBAR1(1)+T*PBAR(1))
		PBAR(1)=SQRT((2D0*I+1D0)/(2D0*I)*(1D0-T**2))*PBAR(1)
	ENDDO
ELSE
	PBAR(1)=P00; PBAR1(1)=0D0
ENDIF
! PM+1,M : JEKEIL (A.3B)
IF(NMAX-M+1>=2) THEN
	PBAR(2)=SQRT(2D0*M+3D0)*T*PBAR(1)
ENDIF
! PN,M (N>=M+2) : JEKELI (A.3A)
DO I=3,NMAX-M+1
	C=((2D0*M+2D0*I-3D0)*(2D0*M+2D0*I-1D0))/((I-1D0)*(2D0*M+I-1D0))
	D=((2D0*M+2D0*I-1D0)*(2D0*M+I-2D0)*(I-2D0))/((2D0*M+2D0*I-5D0)*(I-1D0)*(2D0*M+I-1D0))
	PBAR(I)=SQRT(C)*T*PBAR(I-1)-SQRT(D)*PBAR(I-2)
ENDDO
!
! THE FULLY NORMALIZED ASSOCIATED LEGENDRE FUNCTION - 1ST DERIVATIVE
! P'N,M (N>=M+1) : TSCHERNING (8)
DO I=2,NMAX-M+1
	C=1D0/SQRT(1D0-T**2)*T*(M+I-1)
	D=1D0/SQRT(1D0-T**2)*SQRT((((M+I-1)**2-M**2)*(2D0*(M+I-1)+1D0))/(2D0*(M+I-1)-1D0))
	PBAR1(I)=C*PBAR(I)-D*PBAR(I-1)
ENDDO
!
! THE FULLY NORMALIZED ASSOCIATED LEGENDRE FUNCTION - 2ND DERIVATIVE
! P''N,M (N>=M) : ASSOCIATE LEGENDRE EQUATION (2ND ORDER DIFFERENTIAL EQN.)
DO I=1,NMAX-M+1
	PBAR2(I)=(-T/SQRT(1D0-T**2))*PBAR1(I)-((M+I-1)*(M+I)-M**2/(1D0-T**2))*PBAR(I)
ENDDO
RETURN
END SUBROUTINE LGDR2
